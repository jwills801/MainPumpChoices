%% This code is the one used for the FPMC paper

% Fill / empty the rails so that the accumulators sizes are minimized.
% This code should be generalized so that any flows can be given


clear, close all
% Load Drive Cycle
load('JCB5T_C0P_3CPR_Flows.mat')
% Posative flow is flow leaving the accumulator
dt = t(2);
V1 = cumsum(QR_1)*dt;
V2 = cumsum(QR_2)*dt;
V3 = cumsum(QR_3)*dt;
V = [V1 V3];
%V = [V1 V2 V3];
figure, plot(t,V*1e3)
%legend('Rail 1','Rail 2'), ylabel('Volume (L)'), xlabel('Time (s)')


DPdt = 5; % How quickly can we switch between rails?
dtscale = DPdt/dt; % Step through DP at a different time step than the one given by Drive Cycle
DPt = 0:DPdt:t(end);

% Set flow rate and cost to switch
Qave = max(abs(V(end,:)/t(end)));
Q = 4e-04;

chi = .1;
K = 1.4; % ratio of specific heats - note that it is capitilized

[V_options, nn] = make_V_options(V,Q,DPdt);
% nn is the number of discrete volumes which will be used to make up the
% state space. This is determined from the maximum and minimum volumes for each rail

% Initilize matrices
J   = NaN(prod(nn),length(DPt));
ind = NaN(prod(nn),length(DPt));
for i = 1:size(V,2), V_min{i} = J; V_max{i} = J;  end

% make indexers
indexer = make_indexer(nn,size(V,2));


% V min and max at the end of the time considered
for i = 1:size(V,2)
    V_min{i}(:,end) = V_options{i}(indexer{i}) - V(end,i);
    V_max{i}(:,end) = V_options{i}(indexer{i}) - V(end,i);
end

% Cost at the end of the time considered
for iii = 1:prod(nn)
    J(iii,end) = 0;
    for i = 1:size(V,2)
        J(iii,end) = J(iii,end) + get_accum_size(V_min{i}(iii,end),V_max{i}(iii,end),chi,K);
    end
end

% There are (size(V,2)+1)^2-size(V,2) options for rail configurations
% Start at t(end)
for k = 1:length(DPt)-1
    [~,t_ind] = min(abs(t-(t(end)-k*DPdt))); % The time indice for the fine time mesh
    for iii = 1:prod(nn) % Each option in the state space
        for ii = 1:(size(V,2)+1)^2-size(V,2) % Loop though all the possible decisions at this state and time
            [u(ii), V_min_temp(:,ii), V_max_temp(:,ii)] = calculate_cost(J,t_ind,dtscale,V_min,V_max,V_options,indexer,V,Q,DPdt,iii,ii,k,nn,dt,chi,K) ;
        end
        [J(iii,end-k),ind(iii,end-k)] = min(u); % Which choice to make if you find yourself at state iii at time end-k
        [V_min, V_max] = update_V_max_min(V_min_temp,V_max_temp,V_min,V_max,ind(iii,end-k),iii,k); % using this decison, what are the new V_min and V_max?
    end
    display_percent_done(k,length(DPt));
end

%% Get optimal solution back out
% We have to start at zero deltaV in each rail
zero_indices = zeros(1,length(indexer{1})) == 0;
for i = 1:size(V,2)
        zero_indices = zero_indices & (V_options{i}(indexer{i}) == 0) ;
end
zero_ind = find(zero_indices); % The index where all rails are at zero deltaV

% Check that cost matches up with what V_min and V_max are
total_accum_size_calc1 = 0;
for i = 1:size(V,2)
    total_accum_size_calc1 = total_accum_size_calc1 + get_accum_size(V_min{i}(zero_ind,1),V_max{i}(zero_ind,1),chi,K);
end
abs( total_accum_size_calc1 - min(J(zero_ind,1)) ) / total_accum_size_calc1 < 1e-3 

% Get vector of relevant indices
decision_ind(1) = ind(zero_ind,1);
for k = 2:length(DPt)
    decision_ind(k) = ind(decision_ind(k-1),k-1); % the decision now of where we want to be come next time step
end
figure, plot(DPt,decision_ind)

% What is the volume that the main pump provides over time?
V_MP = zeros(1,size(V,2)) ; 
for k = 1:length(DPt)-1
    [M,P] = valve_orientation(size(V,2),decision_ind(k)) ;
    m(k) = M;
    p(k) = P;
    V_MP_temp = NaN(dtscale,size(V,2));
    for i = 1:size(V,2)
        V_MP_temp(:,i) = V_MP(end,i) + cumsum(Q*dt*ones(dtscale,1))*(P==i) - cumsum(Q*dt*ones(dtscale,1))*(M==i) ;
    end
    V_MP = [V_MP; V_MP_temp];
end

figure, plot(t,V_MP*1e3)

deltaV = V_MP - V;
for i = 1:size(V,2)
    abs( min(deltaV(i,:)) - V_min{i}(zero_ind,1) ) ;
    abs( max(deltaV(i,:)) - V_max{i}(zero_ind,1) ) ;
end
return



% Find what the volume looks like at each time
V_p1 = 0;
V_p2 = 0;
for jj = 1:length(DPt)-1
    V_p1(jj+1) = V_p1(jj) + (ind(current_ind(jj),jj)==2|ind(current_ind(jj),jj)==3)*Q*DPdt;
    V_p2(jj+1) = V_p2(jj) - (ind(current_ind(jj),jj)==1|ind(current_ind(jj),jj)==2)*Q*DPdt;
end


% What is the required accumulator size?
for i = 1:length(t)
    [~,DPt_ind] = min(abs( DPt - t(i) + DPdt/2 - t(2)));
    DelV1(i) =  V_p1(DPt_ind) - V(i,1);
    DelV2(i)=  V_p2(DPt_ind) - V(i,2);
end
%figure, plot(t,DelV1), ylabel('$\Delta V (m^3)$','interpreter','latex'), xlabel('Time (s)','interpreter','latex')
%figure, plot(t,DelV2), ylabel('$\Delta V (m^3)$','interpreter','latex'), xlabel('Time (s)','interpreter','latex')


delV_max1 = max(DelV1) ; [delV_max1, V1_max(end,1)]
delV_min1 = min(DelV1) ; [delV_min1, V1_min(end,1)]
delV_max2 = max(DelV2) ; [delV_max2, V2_max(end,1)]
delV_min2 = min(DelV2) ; [delV_min2, V2_min(end,1)]
Accumulator_size1_actual = get_accum_size(delV_min1,delV_max1,chi,K);
Accumulator_size2_actual = get_accum_size(delV_min2,delV_max2,chi,K);

Total_Accum = Accumulator_size1_actual + Accumulator_size2_actual

figure
plot(t,V*1e3,DPt,V_p1*1e3,DPt,V_p2*1e3), legend('Rail 1 Flow','Rail 2 Flow','Flow delivered to Rail 1 by Pump','Flow delivered to Rail 2 by Pump','Location','NorthWest')
%title(['Accumulator Sizes = [',num2str(Accumulator_size1_actual*1000),' , ',num2str(Accumulator_size2_actual*1000) , ']',' Liters'])
ylabel('Volume (L)'), xlabel('Time (s)')

%% Plot Fluid volume in each accum
Vf1 = DelV1 - delV_min1;
Vf2 = DelV2 - delV_min2;

figure, plot(t,Vf1*1e3,t,Vf2*1e3), xlabel('Time (s)'), ylabel('Volume (L)')

%% plot Pressure in each accum
P1_over_Prail = ( (Accumulator_size1_actual+delV_min1) ./ (Accumulator_size1_actual - Vf1) ).^K;
P2_over_Prail = ( (Accumulator_size2_actual+delV_min2) ./ (Accumulator_size2_actual - Vf2) ).^K;

figure, plot(t,P1_over_Prail-1,t,P2_over_Prail-1), xlabel('Time (s)'), ylabel('$\frac{|P(t) - P_{rail}|}{P_{rail}}$','interpreter','latex','FontSize',22.5), hold on
plot([0, t(end)],[chi, chi],'k--',[0, t(end)],[-chi, -chi],'--k'), ylim(1.25*[-chi chi]), hold off

ylh = get(gca,'ylabel');
gyl = get(ylh);                                                         % Object Information
ylp = get(ylh, 'Position');
set(ylh, 'Rotation',0, 'Position',ylp, 'VerticalAlignment','middle', 'HorizontalAlignment','center')


%% Make table for changing perc_threshold
thresh_vals = [.05 .1 .2] ;
k_vals = [1 1.4];
[a b] = ndgrid(thresh_vals,k_vals);
a = a(:); b = b(:);
for i = 1:length(a)
    chi = a(i);
    K = b(i);
    Accumulator_Size(i) = get_accum_size(delV_min1,delV_max1,chi,K);
end
[a b Accumulator_Size'*1000]

%% Functions!








function Vt = get_accum_size(Vmin,Vmax,chi,k)
    Vmin = min([0,Vmin]);
    Vmax = max([0,Vmax]);

    Vt_1 = -Vmin*(1-(1-chi)^(1/k))^(-1); % Total volume required to keep Vmin within the pressure tolerances
    
    % Find Vt 2...
    Vt_2 = ( (1+chi)^(1/k)*(Vmin-Vmax) - Vmin ) /(1 - (1+chi)^(1/k) );

    % Total required accumulator volume:
    Vt = max([Vt_1 Vt_2]);
end



function [J, V_min_temp, V_max_temp] = calculate_cost(J,t_ind,dtscale,V_min,V_max,V_options,indexer,V,Q,DPdt,iii,ii,k,nn,dt,chi,K)
%% iii is the index we are currently at
% We want to calculate the cost of going to another index indicated by configuration ii
[M,P] = valve_orientation(size(V,2),ii) ; % Which rail is pumping and which is motoring. P = 1 means rail 1 is pumping
next_index = get_next_index(V_options,indexer,M,P,Q,DPdt,size(V,2),iii,nn) ; % Which index position we are moving to as a reults of M and P
if isempty(next_index)
    J = NaN ; % If next_index is empty, this means that the rail we are going to is outside of the state space
    V_min_temp = NaN; V_max_temp = NaN;
else
    V_min_temp = NaN(size(V,2),1); V_max_temp = NaN(size(V,2),1);
    for i = 1:size(V,2)
        V_min_temp(i,1) = V_min{i}(next_index,end-k+1); % Intiliaize with the Max and min volume differences from the index we going to on the next time step
        V_max_temp(i,1) = V_max{i}(next_index,end-k+1);
    end
    for j = 1:dtscale % integrate over the finer time mesh
        for i = 1:size(V,2)
            V_min_temp(i,1) = min([V_min_temp(i,1) , (V_options{i}(indexer{i}(iii))-V(t_ind+j,i) - Q*dt*(j-1)*(i==M) + Q*dt*(j-1)*(i==P) ) ] ) ;
            V_max_temp(i,1) = max([V_max_temp(i,1) , (V_options{i}(indexer{i}(iii))-V(end-k+1,i) - Q*dt*(j-1)*(i==M) + Q*dt*(j-1)*(i==P) ) ] ) ;
        end
    end
    worst_in_section = 0 ;
    for i = 1:size(V,2)
        worst_in_section = worst_in_section + get_accum_size(V_min_temp(i,1), V_max_temp(i,1) ,chi,K) ;
    end
    J = max([J(next_index,end-k+1) , worst_in_section]) ; % do any points between the two DP time steps require larger accumulators?
end
end



function [M,P] = valve_orientation(n,ii)
% Called by calculate_cost

% There are n+1 rails
% M = 0 means that tank is motoring
% P = 1 means that the first rail is pumping
if ii <= n + 1
    M = 0;
    P = ii-1;
else
    M = floor((ii-2)/n);
    P = mod((ii-2),n);
    if P >= M
        P = P + 1 ;
    end
end
end


function [V_min, V_max] = update_V_max_min(V_min_temp,V_max_temp,V_min,V_max,decision,iii,k)
% Called in the main program - inside the for loop which goes over each time step
% This code just puts the V_min_temp from the choice we made into the actual V_min thank we will use later
    for i = 1:length(V_min)
        V_min{i}(iii,end-k) = V_min_temp(i,decision);
        V_max{i}(iii,end-k) = V_max_temp(i,decision);
        % decision tells us which for the options we chose this time step (there are (n+1)^2-n options for n rails)
    end
end



function next_index = get_next_index(V_options,indexer,M,P,Q,DPdt,n,iii,nn)
% Called by calculate_cost
% Given initial index iii, what is the net index if we motor rail M and pump to rail P?
possible_indeces = zeros(1,prod(nn)) == 0;
for i = 1:n
    temp = V_options{i}(indexer{i}) - (V_options{i}(indexer{i}(iii))- Q*DPdt*(i==M) + Q*DPdt*(i==P)) ; 
    possible_indeces = possible_indeces & abs(temp)<1e-9 ;
end
next_index = find(possible_indeces) ;
end


function display_percent_done(k,kf)
% Called in the main DP for loop looping over time
% Display what percent done the for loop is - only at key percentages, like 10 percent
if kf > 100
    step = 100/(kf-1); % The finest step that is ever made
    events = [1:1:9, 10:10:100];

    event_occur = find( abs( events - k*100/(kf-1) ) < step/2 );
    if ~ isempty(event_occur)
        disp(['Dynamic programing loop is ' num2str(events(event_occur)) '% complete'])
    end
else
    disp(['Dynamic programing loop is ' num2str(round(k*100/(kf-1))) '% complete'])
end
end



function [V_options, nn] = make_V_options(V,Q,DPdt)
% Called in main program before main DP loop

% nn is the number of discrete volumes which will be used to make up the
% state space. This is determined from the maximum and minimum volumes for each rail
ss_top = max(V,[],1); % Top of state space
ss_bottom = min(V,[],1); % Bottom of state space
nn_pos = ceil( ss_top/Q/DPdt )     + 2 ; % 1x2 vector  - how many steps would it take to get to the top of the state space?
nn_neg = ceil( -ss_bottom/Q/DPdt ) + 2; % The plus two is to give a little room on the top and bottom of the state space

% Make V_options - which is a matrix of possible values of V_p at each time
for i = 1:size(V,2)
    negative_portion = fliplr(cumsum(-Q*DPdt*ones(1,nn_neg(i)-1)));
    positive_portion = cumsum(Q*DPdt*ones(1,nn_pos(i)-1));
    V_options{i} = [negative_portion 0 positive_portion];
    nn(1,i) = size(V_options{i},2);
end
end



function indexer = make_indexer(nn,n)
% Makes indexer for V_options - this indexer creates a mesh grid so that each index results in a unique point in state space
lhs = [ '[ temp{1} ' ] ;
rhs = [ 'ndgrid( 1:nn(1) ' ] ;
for i = 2:n
    lhs = [ lhs ', temp{' num2str(i) '} ' ] ;
    rhs = [ rhs ', 1:nn(' num2str(i) ') ' ] ;
end
eval( [lhs '] = ' rhs ') ;'] )
for i = 1:n, indexer{i} = temp{i}(:); end
end